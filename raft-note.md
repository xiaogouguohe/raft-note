# raft-extended笔记

## 0 摘要

- raft是一种共识算法
  - 和Paxos功能相同，但是算法结构和Paxos不同，这使得Raft算法更容易理解和实现
- Raft将共识算法分解成了几个关键模块，例如
  - 领导人选举
  - 日志复制
  - 安全性
- Raft通过实施一个更强的共识，来减少需要考虑的状态的数量
- Raft还包括一个新的机制，来允许鸡群成员的动态改变，利用重叠的大多数来保证安全性

## 1 介绍

- 共识算法是什么
  - 一组机器像一个整体一样工作
- Paxos占据统治地位，但是依旧很复杂，因此引入Raft
- Raft通过一些手段来增强它的可理解性，包括
  - 算法分解，分成领导人选举，日志复制和安全性三个模块
  - 减少状态机的状态
- Raft算法和现有的共识算法非常相似，但是也有一些独特的特性
  - 强领导者
    - 日志条目只从领导者发送给其它的服务器
    - 这种做法简化了对付之日止的管理
  - 领导选举
    - 通过一个随机计时器来选举领导者
    - 这只是在任何一种共识算法都要实现的心跳机制上增加了点随机性
    - 方便解决冲突
  - 成员关系调整
    - 使用一种共同意志的方式来处理集群成员变换的问题
- 本文介绍的内容
  - 第2章介绍复制状态机
  - 第3节讨论Paxos的优缺点
  - 第4节讨论为了可理解性而采取的方法
  - 第5~8节阐述Raft共识算法
  - 第9节评价Raft算法
  - 第10节涉及一些相关的工作

## 2 复制状态机

- 什么是状态机：保存一些状态信息的结构，例如
  - 数据（图1中体现为键值对）
  - 当前角色（leader，candidate或follower）
- 共识算法是在复制状态机的背景下提出的
  - 一组服务器上的每个状态机保持相同状态（互为副本），并且在一些机器宕掉的状态也可以继续运行
- 复制状态机是基于复制日志实现的
  - 每个服务器存出一个包含一系列指令的日志，并且按照日志的顺序进行执行
  - 每份日志都按照相同的顺序包含相同的指令，因此每个服务器都执行相同的指令序列
  - 每个状态机都是确定的，因此每次执行操作都产生相同的状态和序列
- 保证所有日志的副本相同，是共识算法的工作
  - 在一台服务器上，共识模块接收客户端的指令，然后增加到自己的日志里
  - 它和其他服务器上的共识模块进行通信，来保证每个服务器的日志都完全相同，哪怕有些服务器会宕机
  - 一旦指令被正确复制，每个服务器的状态机会按照日志顺序执行它们，然后把输出结果返回给客户端
- 共识算法的特性
  - 安全性保证
  - 可用性：集群中只要有大多数机器可运行并且能够互相通信、和客户端通信，就可以保证可用
  - 不依赖时序来保证共识：服务器之间时钟的不一致，延迟这些因素，一般不会导致可用性问题
  - 少部分比较慢的节点不会影响系统整体的性能

## 3 Paxos算法的问题

- 不透明
- 没有很好的工业界实现

## 4 为了可理解性的设计

- 使用了两种通常适用的技术来解决这个问题
  - 问题分解
    - Raft被分成领导人选举，日志复制，安全性和角色改变等几个部分
  - 减少状态的数量，来简化需要考虑的状态空间

## 5 Raft一致性算法

- Raft是一种管理复制日志（第2章）的算法
  - 图2总结了这个算法的简略版本
  - 图3列举了这个算法的一些关键特性
- Raft通过选举出一个领导人，然后给予它全部的管理复制日志的责任来实现共识，这些职责包括
  - 从客户端接收日志条目
  - 把日志条目复制到其他服务器上
  - 当保证安全性的时候，告诉其它的服务器，把日志条目用到它们的状态机上
- 领导人可能宕机，或者和其它服务器失去连接，这种情况下会选举出一个新的领导人
- 通过领导人的方式，Raft将共识性问题分解成三个相对独立的子问题
  - 领导选举
    - 当现存的领导人宕机时，要选取新的领导人（5.2）
  - 日志复制
    - 领导人必须从客户端接收日志条目，然后复制到集群中的其它节点，并且强制要求其它节点的日志和自己的保持相同
  - 安全性
    - 如果有任何的服务器已经应用了一个日志条目到它的状态机中，那么其他服务器不能在同一个索引位置应用不同的日志
    - 5.4会阐述Raft如何保证这个特性
    - 这个解决方案涉及到一个额外的选举机制（5.2）
- 展示一致性算法后，这一章会讨论可用性的一些问题，和计时在系统的作用

- 图2的解释

  - ###

- 图3的解释，Raft在任何时候都需要保证的特性

  - 选举安全：在一个任期内，最多只能选出一个领导者（5.2）
  - 领导者在自己的日志上只会追加，不会重写或者删除日志条目（5.3）
  - 日职匹配：如果两份日志包含了一条索引和任期都相同的日志条目，那么这条条目前面的日志条目也都是匹配的（5.3）
  - 领导者完整性：如果一条日志条目在某个任期内被提交了，那么这条条目会出现在所有比当前任期大的领导者的日志里（5.4）

  - 状态机安全性：如果一个服务器应用了某条日志条目，那么在这个索引位置上，不会有其它服务器应用了其它的一条日志条目（5.4.3）

### 5.1 Raft基础

- 在任何时刻，每个服务器节点都处于三个状态之一

  - 领导人
    - 通常情况下， 系统中只有一个领导人，且其他节点都是追随者
    - 领导人处理所有的客户端请求，如果一个客户端和追随者联系，追随者会把请求重定向给领导人
  - 追随者
    - 不会发送任何请求，只会响应来自领导人或候选人的请求

  - 候选人
    - 选举新领导人时使用（5.2）
  - 图4展示了这些状态和它们之间的转换关系
    - starts up: 服务启动，成为追随者
    - times out, start election: 超时，成为候选人
    - times out, new election: 选举超时，开始新一轮选举
    - receives vote from majority of servers: 获取过半选票，成为领导者
    - discovers current leader or new term: 收到领导人的消息，或是收到新任期的消息，成为追随者
    - discovers server with higher term: 收到任期更大的消息，成为追随者

- Raft把时间分割成任意长度的任期，如图5

  - 任期用整数标记
  - 每段任期从一次选举开始（5.2）
  - 如果一个候选人赢得选举那么它就在接下来的任期内，履行领导人的职责
  - 选举可能选不出领导人，因为可能有多个候选人，造成选票瓜分，此时这一任期没有领导人，会开始新的任期和新一轮选举

- 服务器节点会通过任期，查明一些过期的信息，实现是每个节点会存储一个当前任期号，服务器之间通信时会交换任期号

  - 如果一个服务器的当前任期号比其它人小，就会把自己的任期号更新到新值
  - 如果一个候选人或领导者发现自己的任期号过期了，会立即恢复成追随者状态
  - 如果一个节点收到一个包含过期任期号的请求，它会直接拒绝这个请求

- Raft算法中，要实现基本的共识算法，服务器节点之间的通信只需要两种类型的RPCs

  - 请求投票RPCs（5.2）
    - 候选人在选举期间发起
  - 附加条目RPCs
    - 领导人发起，用来复制日志和提供心跳机制（5.3）
  - 为了在服务器之间传输快照，增加了第三种RPC（第7章）
  - 当服务器没有及时收到RPC响应时，会重试
  - 服务器能够并行发起RPCs来获得最佳性能
    - goroutine发起RPCs

### 5.2 领导人选举

- Raft使用一种心跳机制来触发领导人选举
  - 当服务器启动时，都是追随者
  - 服务器保持追随者状态，只要它从领导人或候选人出接收到有效的RPCs
  - 领导人周期性地向所有追随者发送心跳（不包含日志项内容的RPCs），来维持权威
  - 如果一个追随者在一段时间内没收到任何消息（选举超时），就会发起选举，增加任期号，并且切换到候选人状态
- 候选人会保持当前状态，直到下面事情之一发生（图4）
  - receives vote from majority of servers
    - 要满足以下条件，某个服务器才会给候选人投票
      - 每个服务器最多会对一个任期投出一张选票，按照先来先服务的原则
      - 5.4在投票上加了一些额外的限制
    - 要求获得过半选票，确保最多只有一个领导者（图3的选举安全性）
    - 赢得选举后，立即成为领导人，向其它服务器发送心跳，确立权威，阻止新的领导人产生
  - iscovers current leader or new term
    - 等待投票的时候，候选人可能会从其它的服务器接收到声明它是领导人的附加日志项RPC
    - 这个领导人的任期号会包含在这个RPC中，如果这个任期号不小于候选人当前的任期号，那么候选人会承认领导人合法，并回到追随者状态
    - 如果这个任期号比自己的小，那么候选人会拒绝此次RPC，并保持候选人状态
  - times out, new election
    - 候选人没有赢也没有输
    - 如果有多个候选人，那么选票可能被瓜分，导致没有候选人获得过半选票
    - 这种情况发生时，候选人会超时，然后通过增加任期号来开始新一轮选举
    - 为了防止无限瓜分（大家同时超时，同时发起下一轮选举），通过随机选举超时时间，来避免频繁的选票瓜分

### 5.3 日志复制

#### 5.3.1 领导人为客户端提供服务

- 一旦一个领导人被选举出来，它就开始为客户端提供服务
  - 客户端的每个请求都包含一条被复制状态机执行的指令
  - 领导人把这条指令作为一条新的日志条目，附加到日志中去，然后并行发起附加条目RPCs给其它服务器，让它们复制这条日志条目
  - 当日志条目被安全地复制，领导人会应用这条日志条目到它的状态机，并把执行的结果返回给客户端
    - 后面会介绍怎么样才算安全地复制
    - 日志条目被添加到日志里，和日志条目被应用到状态机，是有区别的

#### 5.3.2 日志的组织方式

- 日志的组织方式见图6
  - 每个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号
    - 似乎应该是领导人附加这条日志条目时，领导人的任期号
  - 任期号用来检查是否出现不一致的情况，同时也用来保证图3中的某些性质
  - 每个日志条目还有一个整数索引，表示它在日志中的位置

#### 5.3.3 安全地复制——已提交

- 领导人决定什么时候把日志条目应用到状态机中是安全的（安全地复制）
  - 这种日志条目被称为已提交
  - 保证所有已提交的日志条目都是持久化的，并且最终会被所有可用的状态机（也就是所有服务器节点）执行
  - 领导人将日志条目复制到大多数服务器节点时，日志条目就会提交（如图6中的条目7），
    - 这条日志条目之前的所有条目也会提交
    - 5.4讨论了某些在领导人改变之后应用这条规则的隐晦内容，也展示了这种提交之前所有条目的做法是安全的
  - 领导人会记录最大的将被提交的日志条目的索引，并且这个索引会被包含在所有附加日志RPCs中，这样其它的服务器节点才能知道最终领导人的提交位置
    - 一旦追随者知道某些日志条目已经提交，它也会将这个日志条目应用到本地的状态机上

#### 5.3.4 日志匹配

- Raft维护了图3中日志匹配的特性

  - 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么它们存储了相同的指令
    - 领导人最多在一个任期里，在指定的一个日志索引位置创建一条日志条目
    - 日志条目在日志中的索引不会改变
  - 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么它们之前的所有日志条目也完全相同
    - 通过附加日志RPC的一个简单的一致性检查来保证这个特性
    - 发送附加日志PRC时，会把新的日志条目的前一条日志条目的索引和任期号包含在里面，如果追随者在它的日志中找不到包含相同索引位置和任期号的条目，它就会拒绝接受这个新的日志条目
    - 这是一个归纳步骤，一开始空的日志状态肯定满足日志匹配，然后在日志扩展时，一致性检查保护了日志匹配特性

- 正常操作中，领导人和跟随者的日志保持一致性，所以附加日志RPC的一致性检查不会失败；然而领导人可能崩溃，这可能导致日志不一致（老的领导人可能没完全复制所有日志条目）

  - 图7展示了追随者的日志可能和新领导人不同
  - Raft算法中，领导人处理不一致，是通过强制追随者直接复制自己的日志，这意味着追随者中的冲突的日志条目会被领导人的日志条目覆盖
    - 关键是不能覆盖已提交的
    - 目前为止的机制是不足以保证不覆盖已提交的日志的，需要在选举的时候进行一些额外的限制（5.4）
  - 领导人必须找到和某个追随者最后达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志条目给追随者
    - 这些操作都在进行附加日志PRC的一致性检查时完成
    - 领导人为每个追随者都维护了一个nextIndex，表示下一个需要发送给追随者的日志条目的索引地址
    - 当领导人刚获得权力时，初始化所有的nextIndex值为自己的最后一条日志的索引加1（图7中的11）
    - 如果一个追随者的日志和领导人的不一致，那么附加日志RPC的一致性检查会失败，领导人会减小nextIndex并重试
    - 最终nextIndex会在某个位置，使得领导人和追随者的日志达成一致，此时附加日志RPC成功，这时把追随者冲突的日志删除并添加上领导人的日志
    - 在以后，追随者的日志就会和领导人保持一致，除非又出现故障

  - 可以通过减少被拒绝的附加日志RPC的次数来优化，比如nextIndex不是每次减1，而是每次跳到上一个任期
    - 这种优化不一定非常有必要，因为本来故障就很少会发生

### 5.4 安全性

- 前面描述了Raft算法如何选举和复制日志，但是目前描述的机制不能充分保证每个状态机都会按照相同顺序执行相同指令
  - 例如，一个追随者之前宕机了一段时间，在这段时间里，其它服务器节点已经提交了若干日志条目，然后这个追随者恢复过来并被选举成为领导人，那它就可能覆盖掉这些已经提交的日志条目
  - 因此需要在领导选举时增加一些限制，保证任何领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图3中的领导人完整性）

- 本届会介绍这个限制的实现，以及展示对完整性的证明，并说明完整性性是如何引导复制状态机做出正确行为的

#### 5.4.1 选举限制

- 在任何基于领导人的共识算法中，领导人都必须存储所有已经提交的日志条目
  - 在某些共识算法中，某个节点即使是一开始并没有包含所有已提交的日志条目，也可能被选举为领导者
  - 它们需要额外的机制来识别丢失的日志条目，并把它们传送给新的领导人，要么在选举阶段，要么在成为领导人之后很快进行
  - 这样的方法导致相当大的额外机制，很复杂

- Raft使用投票的方式来保证赢得选举的候选人一定包含了所有已经提交的日志条目
  - 候选人为了赢得选举，必须联系过半节点，这意味着每个已经提交的日志条目肯定存在于至少一个节点上，因为只有被复制到过半节点上的日志条目才会被提交
  - 如果候选人的日志至少和大多数的服务器节点一样新，那么它一定持有了所有已提交的日志条目，因为按照上述说法，联系过半节点就一定不会漏掉任何一条日志条目
- 更加新的日志
  - 如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新
  - 如果两份日志最后的条目的任期号相同，那么日志长的日志更加新

#### 5.4.2 提交之前任期内的日志条目

- 当领导人得知当前任期内的一条日志条目被存储到大多数服务器上时，就可以提交这条记录
  - 如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志条目
- 但是一个领导人不能因为之前任期里的一条日志条目被保存到大多数服务器上时，就提交这条日志条目，图8展示了为什么不可以这么做
  - 图c中，任期为4，此时不能因为任期为2的日志条目被复制到大多数节点，就去提交任期为2的日志条目，否则d中就覆盖了任期为2的已提交条目
  - 不是说c中不能覆盖任期为2的条目，而是说任期为2的条目是可能被覆盖的，因此不能任期4的时候不能提交任期为2的条目
- 那么如何提交之前任期内的日志条目
  - 一旦当前任期的日志条目，因为被复制到过半节点上而被提交，那么由于日志匹配特性，之前的日志条目也会被提交
- Raft会为所有日志条目保留原始的任期号
  - 提交规则上可能有额外的复杂性
  - 但是容易对日志的任期进行管理，而且新领导人发送的冗余日志条目也更少

#### 5.4.3 安全性论证

- ###

### 5.5 追随者和候选人崩溃

- 目前为止只关注了领导人崩溃的情况
  - 追随者和候选人崩溃后的处理方式简单很多，而且处理方式相同
  - 无限重试直到成功

### 5.6 时间和可用性

- Raft的要求之一是安全性不能依赖时间
  - 系统不能因为某些事件运行得比预期快点或慢点就产生错误结果
  - 但是可用性不可避免地要依赖时间，如消息交换比服务器故障间隔时间长，候选人就没有足够时间赢得选举，无法选出稳定的领导人
- 为了选出并维持一个稳定的领导人，需要满足广播时间 << 选举超时时间 << 平均故障间隔时间
  - 广播时间指的是，从一个服务器并行发送RPCs给其他服务器，到接收响应的平均时间
  - 广播时间和平均故障时间是系统决定的，但是选举超时时间是我们自己选择的

## 6 集群成员变化

- ###

## 7 日志压缩

- Raft的日志是不断增长的，因此需要一定的机制来取出日志里累积的陈旧信息

### 7.1 通过快照实现压缩

- 快照是最简单的压缩方法
  - 整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后那个时间点之前的日志全部丢弃
  - 快照技术已经被使用在Chubby和ZooKeeper中，接下来的章节会介绍Raft中的快照技术
- 增量压缩的方法，例如日志清理或日志结构合并树，都是可行的
  - 这些方法每次仅对一小部分数据进行操作，这就分散了压缩的负载压力
  - 先选择一个已经积累的大量已经被删除或被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域
  - 和简单操作整个数据集合的快照相比，需要一些更复杂的机制
- 图12展示了Raft中快照的基础思想
  - 每个服务器独立创建快照，只包括已经被提交的日志，主要的工作包括将状态机的状态写入快照中
  - Raft也包含少量的元数据
    - lastIncludedIndex，最后被包含索引，被快照取代的最后的日志条目在日志中的索引值，即状态机最后应用的日志
    - lastIncludedTerm，最后被包含的任期，该条目的任期号
    - 保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一条日志条目的索引值和任期号
    - 为了支持集群成员更新（第6章），快照也将最后一次配置存下来
  - 一旦服务器完成一次快照，它就可以删除最后索引位置之间的所有日志和快照了

### 7.2 安装快照RPC

- 尽管这些服务器都是独立创建快照，但领导人偶尔会发送一些快照给落后的追随者
  - 这发生在某个追随者十分缓慢，或刚加入集群（第6章）的时候，此时领导者已经丢弃了下一条要发送给追随者的日志条目时
  - 领导人使用一种叫做安装快照的新的RPC来发送快照给太落后的追随者
  - 追随者通过这个RPC接收到快照时，必须自己决定对于已存在的日志如何处理
    - 有可能快照包含了没有在接收者日志中的日志条目，此时跟随者用快照取代整个日志
    - 也有可能快照是自己日志的前面部分，那么快照包含的条目会被全部删除，但快照后面的条目依旧有效

#### 7.2.1 安装快照RPC的参数和返回值

- 领导人调用安装快照RPC，来将快照的分块发送给追随者，并且总是按顺序发送分块

  | 参数              | 解释                                |
  | ----------------- | ----------------------------------- |
  | term              | 领导人的任期号                      |
  | leaderId          | 领导人的 Id，以便于跟随者重定向请求 |
  | lastIncludedIndex | 快照中包含的最后日志条目的索引值    |
  | lastIncludedTerm  | 快照中包含的最后日志条目的任期号    |
  | offset            | 分块在快照中的字节偏移量            |
  | data[]            | 从偏移量开始的快照分块的原始字节    |
  | done              | 如果这是最后一个分块则为 true       |

#### 7.2.2 接收者实现

1. 如果term < currentTerm就立即回复
   - 领导者任期比自己小，拒绝
2. 如果是第一个分块，就创建一个新的快照
3. 在指定偏移量offset写入数据data[]
4. 如果done为false，则等待更多数据
5. 保存快照文件，并丢弃具有较小索引的部分或全部旧快照
6. 如果现存的日志条目中，有某条日志条目的索引值和任期号与快照中自后包含的日志条目相同，则保留其后的日志条目，并进行回复
7. 丢弃整个日志
8. 使用快照重置状态机，并加载快照的集群配置

#### 7.2.3 快照和心跳

- 快照表明领导人是正常的，追随者在接收并接受快照RPC时，应当重置选举超时计时器

#### 7.2.3 快照和Raft的强领导人原则

- 快照方式背离了Raft的强领导人原则，因为跟随者可以在不知道领导人的情况下创建快照
  - 这种背离是值得的，因为领导人是为了解决在达成共识时候的冲突，但是创建快照的时候，已经达成共识了
  - 另一种快照方案，即领导人创建快照，发送给追随者，但是这样有两个缺点
    - 发送快照浪费带宽
    - 领导人实现变复杂
- 影响快照性能的两个问题
  - 什么时候创建快照
    - 过于频繁会浪费磁盘带宽和其它资源
    - 频率太低会承受耗尽存储容量的风险，也增加了重建日志的事件
    - 一个简单的策略是，当日志大小达到固定大小的时候，就创建一次快照
  - 写入快照需要花费显著的一段时间，并且还不能影响到正常操作
    - 可以通过写时复制的手段来解决这个问题

## 8 客户端交互

- 本章介绍客户端如何同Raft进行交互，包括客户端如何发现领导人，Raft如何支持线性化语义
  - 这些问题对于所有一致性的系统都存在，并且Raft的解决方案和其它的差不多
  - Raft的客户端发送请求给领导人
    - 客户端启动时，会随机挑选一个服务器节点进行通信
    - 如果第一次挑选的服务器节点不是领导人，这个服务器会拒绝客户端请求，并且提供它最近收到的领导人的信息（网络地址）
    - 如果领导人已经崩溃，那么客户端请求会超时，之后会重试
  - Raft的目标是实现线性化语义，级每次操作立即执行，且执行一次，在调用和收到回复之间，但是Raft是可能会执行同一条命令多次的
    - 例如，领导人提交了某条日志条目，但是在响应客户端之前崩溃了，那么客户端会重试这条指令，导致这条指令被再次执行
    - 解决方案是，对于每条指令赋予一个唯一的序列号，然后状态机跟踪每条指令最新的序列号和相应的响应，如果收到一条指令，发现它的序列号已经被执行，就立即返回，而不重新执行
  - 只读操作可以直接处理，而不需要记录日志
    - 这么做可能返回脏数据，因为领导人响应客户端请求时，可能已经被新的领导人废黜，但是它自己不知道
    - 线性化不允许返回脏数据，因此需要两个额外措施，在不使用日志的情况下保证这一点
      - 领导人必须有关于被提交日志的最新信息？？？
        - 领导人完全特性保证了领导人一定拥有所有已提交的日志条目，但是在任期开始的时候，它不知道哪些是已提交的
        - 为了知道这些，它需要提交一条日志条目？？？
        - Raft通过提交一个空白的日志条目来实现这一点
      - 领导人在处理只读请求时必须检查自己是否被废黜
        - 在响应只读请求之前，先和集群中的大多数节点交换一次信条信息
        - 领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性？？？







2A: 5.2，不考虑日志的选举

2B: 5.3，日志复制

2C: 持久化到磁盘（实际上还是内存）

3A: 客户端交互

3B: 快照

4: 集群分组，负载均衡